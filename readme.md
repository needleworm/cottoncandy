Kimchi-Chord 도큐멘테이션
======================

## 1. Markov
n-th order의 마르코프 체인(Markov chain)을 구현한다. 주어진 데이터를 통해 이 모델을 학습할 수 있으며, 학습된 모델에서 학습한 규칙을 토대로 랜덤한 series를 생성할 수 있다.

### 1.1 아규먼트
>
* num_states: 이 마르코프 체인의 스테이트 갯수를 지정한다.
* label: 이 마르코프 체인의 스테이트 이름을 지정한다. 자료형은 tuple이다.
* order: 마르코프 체인의 오더를 지정한다. 3rd-order까지는 안정적이나, 4th-order까지도 유용하게 사용할 수 있을 것이다.

### 1.2 메소드
>
* fit: 주어진 데이터(스트링 리스트 또는 정수 리스트)로 이 모델의 파라미터를 학습시킨다. 이 모델의 파라미터는 프라이빗 애트리뷰트인 transmat_에 있으며, 이 애트리뷰트는 (num_states^order x num_states)의 행렬이다. 데이터를 읽어 나가며 발생한 상태 전이에 해당하는 행렬 원소의 수를 증가시킨다.
* dump_model: 학습한 모델을 pickle 파일의 형태로 저장한다. 초기 파일명은 'markov.pkl'로 지정되어 있다.
* random_gen: 학습한 모델의 규칙을 토대로 새로운 랜덤 리스트를 생성한다. 초기 생성 리스트의 길이는 32로 지정되어 있다.

## 2. StateQueue
이전 상태 전이를 기록해 두기 위한 큐 데이터 타입이다. 일반적인 큐와는 다르게, 큐의 오더라는 개념이 존재한다.

### 2.1 큐의 오더
큐의 오더는 임의의 큐가 가질 수 있는 원소의 최대 갯수를 의미한다. 어떤 큐의 오더가 3이라고 가정하면, 큐의 원소가 두 개일 때는 일반적인 큐처럼 행동한다. 하지만 큐의 원소가 가득찬 상태에서 enqueue 연산을 수행하면, 가장 먼저 들어온 원소를 dequeue한 이후 enqueue 연산을 수행하게 된다. 결론적으로, 한 번 큐가 가득 찬 이후에는 큐에 clear 연산을 수행하지 않는 한 큐의 원소의 갯수가 일정하게 유지되는 것이다.

### 2.2 아규먼트
>
* order: 큐의 오더를 지정한다.

### 2.3 메소드
>
* enqueue: 큐에 한 원소를 삽입한다.
* clear_queue: 큐의 원소를 모두 삭제한다.
* top: 가장 늦게 들어온 큐의 원소를 리턴한다.
* bottom: 가장 먼저 들어온 큐의 원소를 리턴한다.
* is_empty: 큐가 비어 있는지 확인한다.
* get_states: 큐의 원소(상태 전이 이력)를 확인한다.
* get_calibrated_states: 위의 메소드와 동일한 역할을 하지만, Line 모듈에 사용하기 위해 보정을 거친다.

## 3. Chord
코드 프로그레션을 시뮬레이션하기 위한 마르코프 체인으로, Markov 클래스를 상속한다. 일반적인 마르코프 체인에 lookup-table을 추가해 코드 variant(Cm, CM7, Cdim7, etc.)를 추적할 수 있게 구현하였다.

### 3.1 아규먼트
* var_list: 가능한 코드 variant의 목록이다. variant의 목록은 helper 모듈의 variant_list 함수로 구할 수 있다.

## 4. Line
멜로디와 베이스 라인을 학습하고 생성하는 마르코프 체인으로 Markov 클래스를 상속한다. 시드 음을 받아서 시드 음을 확장하는 방식으로 멜로디 라인을 생성한다.

### 4.1 피팅 방법
피아노 건반에 번호를 매겨서 음을 표시하기로 하자.

> 예시
C0 = 0, C#0 = 1, D0 = 2, ..., C4 = 60, C#4 = 61, ...

그리고 우리가 사용할 모델이 오더 3의 마르코프 체인이라 가정해 보자. 만약 주어진 데이터가

> [60, 62, 64, 62, 60]

이라면, 데이터의 세 번째 원소까지 순회했을 때의 모델의 *과거 상태 이력*은 (60, 62, 64)이고, *상태 전이 이력*은 (0, +2, +4)가 된다. 상태 전이 이력의 가장 첫 상태는 0, 나머지 상태들은 첫 번째 상태와의 음 간격으로 정의한다.

그 다음, 데이터의 다음 원소인 62는 상태 전이 이력의 첫 원소와 비교했을 때 음 간격이 +2이므로, 새로운 상태 전이는

> (0, +2, +4) ==> +2

으로 나타낼 수 있다. 그리고 방금 진행된 상태 전이를 모델에 저장하면 과거 상태 이력은 (62, 64, 62)가 될 것이다. 그러면 바로 위에서 언급한 정의에 따라 이때의 상태 전이 이력은 (0, +2, 0)이 된다.

마지막 원소까지 순회해 보자. 마지막 원소는 60으로, 상태 전이 이력의 첫째 원소와 비교했을 때의 상태값은 -2이다. 그러므로 마지막 상태 정의는

> (0, +2, 0) ==> -2

가 된다. 이를 통하여 모델이 기억하고 있는 가장 오래된 음을 기준으로 다음 음들의 높낮이를 기억하여 확률 분포를 계산하는 것이다.

### 4.2 아규먼트
>
* seed_note: 시드 노트로, 정수의 리스트 타입이다.
* order: 마르코프 체인의 오더이다. 3rd-order까지 안정적이며, 4th-order까지 유용하게 사용할 수 있다.

### 4.3 정적 메소드
>
* strip_: 샘플 데이터에서 -1(비어 있음)을 제거하기 위한 메소드이다. degree의 값에 따라 -1이 연속 degree개가 붙어서 나타날 때만 제거할 수 있도록 할 수 있다.
* leap_check_: 심한 음 도약이 일어나는지 체크한다. 심한 음 도약이 일어난 경우 멜로디 생성을 도약음부터 다시 시작하게 한다.

## 5. helper
본 패키지의 헬퍼 함수들이다. 자주 쓰이는 vocabulary를 딕셔너리 형태로 저장해 두었다.

### 5.1 shift_pitch(pitch, interval, mode)
주어진 음을 주어진 음정만큼 옮긴다. 아규먼트 mode는 옮긴 결과를 # 또는 b 형식 중 어떤 형식으로 표기할 지 결정한다.

### 5.2 calc_interval(lhs, rhs)
주어진 두 음 사이의 음정을 구한다. lhs가 낮은 음이고, rhs가 높은 음이다.

### 5.3 transpose(chords, prev_key, res_key)
주어진 코드 프로그레션의 조성을 prev_key에서 res_key로 옮긴다.

### 5.4 make_interval_chord(chords, key)
key 조성의 주어진 코드 프로그레션을 음정 코드 표기법으로 바꾼다.

### 5.5 open_pickle(pkl_name)
pickle 파일로 저장되어 있는 모델을 연다.

### 5.6 text_to_sample(input_name)
텍스트 파일로부터 샘플을 읽어들인다.

### 5.7 variant_list(input_name, var_list)
텍스트 파일로부터 가능한 variant의 종류들을 파악한다.

### 5.8 translate_to_chord(state_prog)
상태 전이 기록으로부터 코드 프로그레션을 얻어낸다.